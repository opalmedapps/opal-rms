<?php declare(strict_types = 1);

namespace Orms\DataAccess;

use PDO;

use Orms\Config;
use Orms\DatabaseConfig;

//returns db connection handles to a requested database
class Database
{
    private static ?PDO $ormsConnection = NULL;
    private static ?PDO $logsConnection = NULL;
    private static ?PDO $opalConnection = NULL;
    private static ?PDO $questionnaireConnection = NULL;

    /** @var array<int,int> */
    private static array $pdoOptions = [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
    ];

    static function getOrmsConnection(): PDO
    {
        if(self::$ormsConnection === NULL) {
            $dbInfo = Config::getApplicationSettings()->ormsDb;
            self::$ormsConnection = self::_getDatabaseConnection($dbInfo);
        }

        return self::$ormsConnection;
    }

    static function getLogsConnection(): PDO
    {
        if(self::$logsConnection === NULL) {
            $dbInfo = Config::getApplicationSettings()->logDb;
            self::$logsConnection = self::_getDatabaseConnection($dbInfo);
        }

        return self::$logsConnection;
    }

    private static function _getDatabaseConnection(DatabaseConfig $dbConf): PDO
    {
        return new PDO(
            self::_generateMysqlConnectionString($dbConf->host,$dbConf->port,$dbConf->databaseName),
            $dbConf->username,
            $dbConf->password,
            self::$pdoOptions
        );
    }

    private static function _generateMysqlConnectionString(string $host,string $port,string $dbName): string
    {
        return "mysql:host={$host};port={$port};dbname={$dbName}";
    }

    /**
     * Function that converts an sql string with a placeholder into an sql string with autogenerated placeholders, one for each input element. Also returns the needed bindParam array.
     * This function is usually used to prevent input sql inject in IN statements.
     * For example, instead of writing "A.B IN ('x1','x2','x3')", this becomes "A.B IN (:bindParamB1,:bindParamB2,:bindParamB3)" preventing sql injection.
     * @param mixed[] $elements
     * @return array{
     *      sqlString: string,
     *      boundValues: array
     * }
     */
    static function generateBoundedSqlString(string $sql,string $placeholder,string $tableName,string $columnName,array $elements): array
    {
        $boundElements = [];

        if($elements === []) {
            $bindString = NULL;
        }
        else {
            $boundIndexes = [];

            foreach($elements as $index => $val)
            {
                $boundIndexes[] = ":bindParam$columnName$index";
                $boundElements[":bindParam$columnName$index"] = $val;
            }

            $bindString = "$tableName.$columnName IN (". implode(",",$boundIndexes) .")";
        }

        $sqlString = str_replace($placeholder,$bindString ?? "1=1",$sql); //if the input array was empty, remove the placeholder

        return [
            "sqlString"   => $sqlString,
            "boundValues" => $boundElements
        ];
    }

    /**
     *
     * @return list<array{
     *      table: string,
     *      column: string,
     *      constraintName: string,
     *      referencedTable: string,
     *      referencedColumn: string
     *   }>
     */
    static function getForeignKeysConnectedToColumn(PDO $dbh,string $tableName,string $columnName): array
    {
        $query = $dbh->prepare("
            SELECT
                TABLE_NAME,
                COLUMN_NAME,
                CONSTRAINT_NAME,
                REFERENCED_TABLE_NAME,
                REFERENCED_COLUMN_NAME
            FROM
                INFORMATION_SCHEMA.KEY_COLUMN_USAGE
            WHERE
                REFERENCED_TABLE_SCHEMA = DATABASE()
                AND REFERENCED_TABLE_NAME = :tableName
                AND REFERENCED_COLUMN_NAME = :columnName
        ");
        $query->execute([
            ":tableName"    => $tableName,
            ":columnName"   => $columnName
        ]);

        return array_map(function($x) {
            return [
                "table"             => $x["TABLE_NAME"],
                "column"            => $x["COLUMN_NAME"],
                "constraintName"    => $x["CONSTRAINT_NAME"],
                "referencedTable"   => $x["REFERENCED_TABLE_NAME"],
                "referencedColumn"  => $x["REFERENCED_COLUMN_NAME"],
            ];
        },$query->fetchAll());
    }

}
