<?php

declare(strict_types=1);

namespace Orms\DataAccess;

use Orms\Config;
use Orms\DatabaseConfig;
use PDO;

//returns db connection handles to a requested database
class Database
{
    private static ?PDO $ormsConnection = null;
    private static ?PDO $logsConnection = null;

    /** @var array<int,int> */
    private static array $pdoOptions = [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC
    ];

    public static function getOrmsConnection(): PDO
    {
        if(self::$ormsConnection === null) {
            $dbInfo = Config::getApplicationSettings()->ormsDb;
            self::$ormsConnection = self::_getDatabaseConnection($dbInfo);
        }

        return self::$ormsConnection;
    }

    public static function getLogsConnection(): PDO
    {
        if(self::$logsConnection === null) {
            $dbInfo = Config::getApplicationSettings()->logDb;
            self::$logsConnection = self::_getDatabaseConnection($dbInfo);
        }

        return self::$logsConnection;
    }

    private static function _getDatabaseConnection(DatabaseConfig $dbConf): PDO
    {
        if($dbConf->usessl) {
            self::$pdoOptions[PDO::MYSQL_ATTR_SSL_CA] = $dbConf->sslca;
            self::$pdoOptions[PDO::MYSQL_ATTR_SSL_VERIFY_SERVER_CERT] = true;
        }
        return new PDO(
            self::_generateMysqlConnectionString($dbConf->host, $dbConf->port, $dbConf->databaseName),
            $dbConf->username,
            $dbConf->password,
            self::$pdoOptions
        );
    }

    private static function _generateMysqlConnectionString(string $host, string $port, string $dbName): string
    {
        return "mysql:host={$host};port={$port};dbname={$dbName}";
    }

    /**
     * Function that converts an sql string with a placeholder into an sql string with autogenerated placeholders, one for each input element. Also returns the needed bindParam array.
     * This function is usually used to prevent input sql inject in IN statements.
     * For example, instead of writing "A.B IN ('x1','x2','x3')", this becomes "A.B IN (:bindParamB1,:bindParamB2,:bindParamB3)", preventing sql injection.
     * @param mixed[] $elements
     * @return array{
     *      sqlString: string,
     *      boundValues: array<string,mixed>
     * }
     */
    public static function generateBoundedSqlString(string $sqlString, string $placeholder, string $column, array $elements): array
    {
        $boundElements = [];
        $placeholderStripped = str_replace(":", "", $placeholder);

        if($elements === []) {
            $bindString = null;
        }
        else {
            $boundIndexes = [];

            foreach($elements as $index => $val)
            {
                $boundIndexes[] = ":bindParam$placeholderStripped$index";
                $boundElements[":bindParam$placeholderStripped$index"] = $val;
            }

            $bindString = "$column IN (". implode(",", $boundIndexes) .")";
        }

        $sqlString = str_replace($placeholder, $bindString ?? "1=1", $sqlString); //if the input array was empty, neutralize the placeholder

        return [
            "sqlString"   => $sqlString,
            "boundValues" => $boundElements
        ];
    }

    /**
     *
     * @return list<array{
     *      table: string,
     *      column: string,
     *      constraintName: string,
     *      referencedTable: string,
     *      referencedColumn: string
     *   }>
     */
    public static function getForeignKeysConnectedToColumn(PDO $dbh, string $tableName, string $columnName): array
    {
        $query = $dbh->prepare("
            SELECT
                TABLE_NAME,
                COLUMN_NAME,
                CONSTRAINT_NAME,
                REFERENCED_TABLE_NAME,
                REFERENCED_COLUMN_NAME
            FROM
                INFORMATION_SCHEMA.KEY_COLUMN_USAGE
            WHERE
                REFERENCED_TABLE_SCHEMA = DATABASE()
                AND REFERENCED_TABLE_NAME = :tableName
                AND REFERENCED_COLUMN_NAME = :columnName
        ");
        $query->execute([
            ":tableName"    => $tableName,
            ":columnName"   => $columnName
        ]);

        return array_map(function($x) {
            return [
                "table"             => $x["TABLE_NAME"],
                "column"            => $x["COLUMN_NAME"],
                "constraintName"    => $x["CONSTRAINT_NAME"],
                "referencedTable"   => $x["REFERENCED_TABLE_NAME"],
                "referencedColumn"  => $x["REFERENCED_COLUMN_NAME"],
            ];
        }, $query->fetchAll());
    }

}
